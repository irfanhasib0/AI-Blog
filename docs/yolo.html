<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_8s7n3kf664eg-8{list-style-type:none}ul.lst-kix_8s7n3kf664eg-7{list-style-type:none}.lst-kix_4gvvutwnlpi-1>li:before{content:"-  "}.lst-kix_4gvvutwnlpi-0>li:before{content:"-  "}.lst-kix_4gvvutwnlpi-5>li:before{content:"-  "}.lst-kix_4gvvutwnlpi-4>li:before{content:"-  "}.lst-kix_4gvvutwnlpi-6>li:before{content:"-  "}.lst-kix_4gvvutwnlpi-2>li:before{content:"-  "}.lst-kix_4gvvutwnlpi-3>li:before{content:"-  "}.lst-kix_p7e7tkpe56mn-8>li:before{content:"-  "}.lst-kix_p7e7tkpe56mn-7>li:before{content:"-  "}.lst-kix_4gvvutwnlpi-8>li:before{content:"-  "}.lst-kix_4gvvutwnlpi-7>li:before{content:"-  "}.lst-kix_p7e7tkpe56mn-5>li:before{content:"-  "}.lst-kix_p7e7tkpe56mn-6>li:before{content:"-  "}.lst-kix_mnrrbqvs6ca-8>li:before{content:"-  "}.lst-kix_mnrrbqvs6ca-6>li:before{content:"-  "}.lst-kix_mnrrbqvs6ca-5>li:before{content:"-  "}.lst-kix_mnrrbqvs6ca-7>li:before{content:"-  "}.lst-kix_mnrrbqvs6ca-0>li:before{content:"-  "}.lst-kix_mnrrbqvs6ca-2>li:before{content:"-  "}.lst-kix_mnrrbqvs6ca-1>li:before{content:"-  "}.lst-kix_mnrrbqvs6ca-4>li:before{content:"-  "}.lst-kix_mnrrbqvs6ca-3>li:before{content:"-  "}ul.lst-kix_4gvvutwnlpi-2{list-style-type:none}.lst-kix_y89d79xx04k4-0>li:before{content:"-  "}.lst-kix_y89d79xx04k4-1>li:before{content:"-  "}ul.lst-kix_4gvvutwnlpi-1{list-style-type:none}ul.lst-kix_4gvvutwnlpi-4{list-style-type:none}ul.lst-kix_4gvvutwnlpi-3{list-style-type:none}.lst-kix_y89d79xx04k4-2>li:before{content:"-  "}ul.lst-kix_4gvvutwnlpi-0{list-style-type:none}ul.lst-kix_4gvvutwnlpi-6{list-style-type:none}.lst-kix_y89d79xx04k4-7>li:before{content:"-  "}ul.lst-kix_4gvvutwnlpi-5{list-style-type:none}ul.lst-kix_4gvvutwnlpi-8{list-style-type:none}ul.lst-kix_4gvvutwnlpi-7{list-style-type:none}.lst-kix_y89d79xx04k4-6>li:before{content:"-  "}.lst-kix_y89d79xx04k4-4>li:before{content:"-  "}.lst-kix_y89d79xx04k4-5>li:before{content:"-  "}.lst-kix_y89d79xx04k4-3>li:before{content:"-  "}.lst-kix_p7e7tkpe56mn-3>li:before{content:"-  "}ul.lst-kix_10bg29dgyeg1-8{list-style-type:none}ul.lst-kix_10bg29dgyeg1-7{list-style-type:none}.lst-kix_p7e7tkpe56mn-0>li:before{content:"-  "}.lst-kix_p7e7tkpe56mn-4>li:before{content:"-  "}ul.lst-kix_10bg29dgyeg1-6{list-style-type:none}ul.lst-kix_10bg29dgyeg1-5{list-style-type:none}ul.lst-kix_10bg29dgyeg1-4{list-style-type:none}ul.lst-kix_10bg29dgyeg1-3{list-style-type:none}ul.lst-kix_10bg29dgyeg1-2{list-style-type:none}ul.lst-kix_10bg29dgyeg1-1{list-style-type:none}.lst-kix_p7e7tkpe56mn-1>li:before{content:"-  "}ul.lst-kix_10bg29dgyeg1-0{list-style-type:none}.lst-kix_p7e7tkpe56mn-2>li:before{content:"-  "}.lst-kix_8s7n3kf664eg-0>li:before{content:"-  "}.lst-kix_8s7n3kf664eg-2>li:before{content:"-  "}.lst-kix_8s7n3kf664eg-1>li:before{content:"-  "}.lst-kix_8s7n3kf664eg-8>li:before{content:"-  "}.lst-kix_10bg29dgyeg1-4>li:before{content:"-  "}.lst-kix_10bg29dgyeg1-3>li:before{content:"-  "}.lst-kix_10bg29dgyeg1-5>li:before{content:"-  "}.lst-kix_10bg29dgyeg1-2>li:before{content:"-  "}.lst-kix_10bg29dgyeg1-6>li:before{content:"-  "}.lst-kix_8s7n3kf664eg-5>li:before{content:"-  "}ul.lst-kix_y89d79xx04k4-5{list-style-type:none}ul.lst-kix_y89d79xx04k4-4{list-style-type:none}ul.lst-kix_mnrrbqvs6ca-8{list-style-type:none}ul.lst-kix_y89d79xx04k4-7{list-style-type:none}ul.lst-kix_mnrrbqvs6ca-7{list-style-type:none}ul.lst-kix_y89d79xx04k4-6{list-style-type:none}ul.lst-kix_mnrrbqvs6ca-6{list-style-type:none}.lst-kix_8s7n3kf664eg-4>li:before{content:"-  "}ul.lst-kix_y89d79xx04k4-1{list-style-type:none}ul.lst-kix_mnrrbqvs6ca-5{list-style-type:none}ul.lst-kix_y89d79xx04k4-0{list-style-type:none}ul.lst-kix_mnrrbqvs6ca-4{list-style-type:none}ul.lst-kix_y89d79xx04k4-3{list-style-type:none}ul.lst-kix_mnrrbqvs6ca-3{list-style-type:none}ul.lst-kix_y89d79xx04k4-2{list-style-type:none}ul.lst-kix_mnrrbqvs6ca-2{list-style-type:none}.lst-kix_8s7n3kf664eg-3>li:before{content:"-  "}ul.lst-kix_mnrrbqvs6ca-1{list-style-type:none}ul.lst-kix_mnrrbqvs6ca-0{list-style-type:none}.lst-kix_10bg29dgyeg1-0>li:before{content:"-  "}.lst-kix_10bg29dgyeg1-1>li:before{content:"-  "}.lst-kix_8s7n3kf664eg-6>li:before{content:"-  "}.lst-kix_8s7n3kf664eg-7>li:before{content:"-  "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_y89d79xx04k4-8>li:before{content:"-  "}ul.lst-kix_p7e7tkpe56mn-8{list-style-type:none}ul.lst-kix_p7e7tkpe56mn-7{list-style-type:none}ul.lst-kix_p7e7tkpe56mn-6{list-style-type:none}ul.lst-kix_p7e7tkpe56mn-5{list-style-type:none}ul.lst-kix_y89d79xx04k4-8{list-style-type:none}ul.lst-kix_p7e7tkpe56mn-4{list-style-type:none}ul.lst-kix_p7e7tkpe56mn-3{list-style-type:none}ul.lst-kix_p7e7tkpe56mn-2{list-style-type:none}ul.lst-kix_p7e7tkpe56mn-1{list-style-type:none}ul.lst-kix_8s7n3kf664eg-4{list-style-type:none}.lst-kix_10bg29dgyeg1-8>li:before{content:"-  "}ul.lst-kix_p7e7tkpe56mn-0{list-style-type:none}ul.lst-kix_8s7n3kf664eg-3{list-style-type:none}ul.lst-kix_8s7n3kf664eg-6{list-style-type:none}.lst-kix_10bg29dgyeg1-7>li:before{content:"-  "}ul.lst-kix_8s7n3kf664eg-5{list-style-type:none}ul.lst-kix_8s7n3kf664eg-0{list-style-type:none}ul.lst-kix_8s7n3kf664eg-2{list-style-type:none}ul.lst-kix_8s7n3kf664eg-1{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c31{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:110.2pt;border-top-color:#000000;border-bottom-style:solid}.c30{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:114.8pt;border-top-color:#000000;border-bottom-style:solid}.c15{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:138pt;border-top-color:#000000;border-bottom-style:solid}.c24{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:120.8pt;border-top-color:#000000;border-bottom-style:solid}.c20{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:118.5pt;border-top-color:#000000;border-bottom-style:solid}.c16{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:111.8pt;border-top-color:#000000;border-bottom-style:solid}.c34{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:117.8pt;border-top-color:#000000;border-bottom-style:solid}.c17{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:463.5pt;border-top-color:#000000;border-bottom-style:solid}.c9{color:#666666;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:italic}.c27{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Times New Roman";font-style:italic}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c14{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Times New Roman";font-style:italic}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c2{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:italic}.c36{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:justify}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c33{color:#000000;text-decoration:none;vertical-align:baseline;font-size:16pt;font-style:italic}.c32{color:#666666;text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:italic}.c7{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c22{color:#000000;text-decoration:none;vertical-align:baseline;font-size:10pt;font-style:normal}.c18{color:#000000;text-decoration:none;font-size:11pt;font-style:normal}.c35{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c40{margin-left:auto;border-spacing:0;border-collapse:collapse;margin-right:auto}.c25{color:#ff9900;text-decoration:none;vertical-align:baseline;font-style:normal}.c10{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c0{vertical-align:sub;font-family:"Times New Roman";font-weight:400}.c41{background-color:#ffffff;max-width:648pt;padding:72pt 72pt 72pt 72pt}.c12{font-size:12pt;font-family:"Times New Roman";font-weight:700}.c5{font-weight:400;font-family:"Times New Roman"}.c37{font-size:14pt;font-style:italic}.c28{font-weight:700;font-family:"Times New Roman"}.c8{margin-left:36pt;padding-left:0pt}.c11{color:inherit;text-decoration:inherit}.c26{padding:0;margin:0}.c13{font-size:12pt}.c42{height:11pt}.c38{font-style:italic}.c21{height:0pt}.c23{font-size:10pt}.c19{vertical-align:super}.c39{font-size:14pt}.c29{margin-left:36pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c41 doc-content"><p class="c36"><span class="c37 c28">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c28 c33">Object Detection : Single Shot Detectors (YOLO V1-V3 , SSD)</span></p><hr><p class="c3"><span class="c27"></span></p><p class="c3"><span class="c14"></span></p><p class="c4"><span class="c27">Faster RCNN Recap :</span></p><hr><p class="c3"><span class="c5 c7"></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c5 c13">Among the RCNN Family of algorithms discussed in the </span><span class="c10 c5 c13"><a class="c11" href="https://www.google.com/url?q=https://irfanhasib0.github.io/blogs/%23/rcnn/&amp;sa=D&amp;source=editors&amp;ust=1667572886854957&amp;usg=AOvVaw0uvq-IUSwi83j6K9lc-mUa">previous article</a></span><span class="c5 c13">, Faster RCNN (2015) and Mask RCNN (2017) are the fastest and most accurate. After Faster RCNN &nbsp;YOLO v1 and then SSD was published and started to get popular in the object detection community. Both of them are single shot detectors; it means they take one RGB image as input and predict the bboxes and class (bounding boxes) by passing the image data only once through different sections of the model. These three algorithms are nearly contemporary and share many relevant upgrades. &nbsp;I will start this section with YOLO-v1 and SSD, then will cover YOLO-v2 and YOLO-v3 as well. For knowing details about Mask RCNN or Faster RCNN please refer to the blog on </span><span class="c10 c5 c13"><a class="c11" href="https://www.google.com/url?q=https://irfanhasib0.github.io/blogs/%23/rcnn/&amp;sa=D&amp;source=editors&amp;ust=1667572886855245&amp;usg=AOvVaw0MZ3P8-TVNxoahVKRKU6cZ">RCNN &nbsp;Family</a></span><span class="c1">. </span></p><p class="c4"><span class="c1">&nbsp; &nbsp; Before we start, let&rsquo;s remember a little about Faster RCNN. &nbsp;One major drawback of Faster RCNN is that it is still quite slow(~ 7 FPS), consequently fails to support many of the real time applications which require faster prediction. It was able to achieve the region proposals and Fmap RoIs by one pass through a network by sharing most of the convolutional layers. The major bottleneck &nbsp;of Faster RCNN is that it still requires one by one passing of the feature maps through the classifier, possibly it is one of the key factors that helps the algorithm to reach its high level of &nbsp;accuracy. YOLO tried to make a tradeoff between speed and accuracy. It replaced the one by one Fmap processing with an end to end manner. The bbox regressor is a tensor having the width and height of the feature map and a depth of 4k + 2k , k = number of anchor bbox ; 4 -&gt; {x,y,w,z} ; 2-&gt; {object , no object confidence}. So at every feature map location it is able to predict k no of box coordinates and confidence. Unlike Faster RCNN it only learns objectness confidence not background confidence.</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c5 c13">&nbsp; &nbsp; &nbsp; </span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 746.50px; height: 398.37px;"><img alt="" src="files/yolo/image7.png" style="width: 746.50px; height: 398.37px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c32 c28">Figure : Faster RCNN </span></p><p class="c3"><span class="c32 c28"></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c27">YOLO Version 1 </span></p><hr><p class="c3"><span class="c27"></span></p><p class="c4"><span class="c5 c13">YOLO v1 stacked the two different branches of RPN together, which were for 4k bbox coordinates and 2k confidence respectively. So across the depth it has one additional channel for class agnostic box confidence. It also stacked extra N channels at the end of this output tensor dedicated for each class. They can predict the probability of each of the object classes per feature map location. It eliminates the necessity of additional &nbsp;classifiers layers and effectively makes it a single shot detector.</span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c2">Improvements :</span></p><p class="c4"><span class="c12">1. Joining the Region Proposal Generator and Classifier together &nbsp;:</span><span class="c1">&nbsp;For YOLO the RPN tensor , confidence tensor (objectnes confidence only), the classifier tensors are all stacked together. Consequently, the outputs of the RPN are required to be dealt separately for projecting on top of the feature map. </span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c12">2. Eliminating RoI Align :</span><span class="c1">&nbsp;</span></p><p class="c4"><span class="c1">[i] Faster RCNN predicts the Region Proposal bbox wrt the original image size so they need to be scaled down for projecting on the featuremap. YOLO directly predicts the region proposals on top of the feature map so no need to scale down and projection anymore. </span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">[ii] Faster RCNN requires the Fmap RoI to be of fixed size so that they can be fed to the classifier layers but here the classification is done parallely for every region proposal at every feature map location. No need to input the feature maps to the classifier layers again.</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c12">3. Eliminated One by One Fmap RoI classification :</span><span class="c1">&nbsp;It is done more efficiently by jointly predicting the bboxes and class probabilities (for every object) at every featuremap location.</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c2">Draw backs :</span></p><p class="c4"><span class="c1">It does not use an anchor box in v1. Eventually v2 adopted it. </span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c2">How it works : </span></p><p class="c4"><span class="c12">&nbsp; &nbsp; &nbsp; </span><span class="c1">In the context of deep convolutional neural networks the output from every CNN stage is a 3D array which we are calling feature maps. It represents distinct high level information across the channels for each of the spatial pixel locations. &nbsp;Usually, the first two dimensions are width and height gradually shrinks down from the original image while the depth gets increased in parallel. It enables the deeper layers to represent more complex image features by each of its depth channels depthwise.</span></p><p class="c4"><span class="c12">&nbsp; &nbsp; &nbsp; </span><span class="c1">The YOLO model takes an image and outputs an array of shape 7x7xN. Each of the channels of the output tensor represent - &ldquo;x,y,w,h,objectness confidence, class 1 confidence, class 2 confidence, ........., class n confidence&rdquo; respectively at every 7x7 grid location. The following example will make it more clear. The red circle on the grid (figure below) represents the 1x2 location in the featuremap. So the numeric value at (grid_x,grid_y,chanel) will represent the following information -</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; </span></p><a id="t.8d740092d50839d677c0c827cdd6281d9c117a30"></a><a id="t.0"></a><table class="c40"><tr class="c21"><td class="c15" colspan="1" rowspan="1"><p class="c6"><span class="c1">(Grid X, Grid Y, Channel)</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c6"><span class="c1">Information</span></p></td></tr><tr class="c21"><td class="c15" colspan="1" rowspan="1"><p class="c4"><span class="c1">(1x2x0)</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c4"><span class="c1">x ; If there is a object at this location, &nbsp;&#39;x&#39; would be the offset of its location along the height</span></p></td></tr><tr class="c21"><td class="c15" colspan="1" rowspan="1"><p class="c4"><span class="c1">(1x2x1)</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c4"><span class="c1">y; &nbsp;similarly &#39;y&#39; would be its offset along width.</span></p></td></tr><tr class="c21"><td class="c15" colspan="1" rowspan="1"><p class="c4"><span class="c1">(1x2x2)</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c4"><span class="c1">w; &nbsp;&#39;w&#39; is the width of the object bbox</span></p></td></tr><tr class="c21"><td class="c15" colspan="1" rowspan="1"><p class="c4"><span class="c1">(1x2x3)</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c4"><span class="c1">h; &nbsp; &#39;h&#39; is the height of the bbox.</span></p></td></tr><tr class="c21"><td class="c15" colspan="1" rowspan="1"><p class="c4"><span class="c1">(1x2x4)</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c4"><span class="c1">probability of presence of any class object at that location.</span></p></td></tr><tr class="c21"><td class="c15" colspan="1" rowspan="1"><p class="c4"><span class="c1">(1x2x5)</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c4"><span class="c1">probability of the presence of a &#39;class 1&#39; object at that location</span></p></td></tr><tr class="c21"><td class="c15" colspan="1" rowspan="1"><p class="c4"><span class="c1">&nbsp;&hellip;</span></p><p class="c4"><span class="c1">&nbsp;&hellip;</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c6"><span class="c1">&hellip;</span></p><p class="c6"><span class="c1">&hellip;</span></p></td></tr><tr class="c21"><td class="c15" colspan="1" rowspan="1"><p class="c4"><span class="c1">(1x2x n+5)</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c4"><span class="c1">probability of the presence of a &#39;class n&#39; object at that location </span></p></td></tr></table><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">They designed the loss function in such a way that the model only learns the x,y offsets from the grid corner, not the absolute pixel coordinate of the object in the image (See x,y values in the enlarged figure in the bottom-right side). The absolute coordinate is derived from the grid location of the feature map. Its value is restricted from 0-1 by applying sigmoid activation function, so that it does not cross the current cell boundary. If it needed to learn the absolute coordinate the value of x,y needed to cover the entire image width and height. Learning an object&#39;s location in the entire image precisely is a harder task then just learning its location within the grid.</span></p><p class="c4"><span class="c1">Now x,y covers a small portion of the region but for w, h there is no restriction for staying within the grid. So w,h loss can get very high sometimes for big boxes. It can make the training unstable for all the losses since they are added together for gradient calculation. For handling this issue they use the difference between the square root of w and h instead of their actual value (Just to remind Faster RCNN was using log scale here). See the loss function below for better understanding.</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 860.42px; height: 473.90px;"><img alt="" src="files/yolo/image9.png" style="width: 860.42px; height: 473.90px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c5 c13">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c9">Figure : Yolo V1</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c12 c38">The Algorithm </span></p><p class="c4"><span class="c1">&nbsp;One thing is avoided intentionally for simplicity. Yolo v1 uses two boxes at each pixel location. So there would be two sets of x,y,w,h like -&gt; x1,y1,w1,h1 , x2,y2,w2,h2. &nbsp;Resulting the depth as follows - 2 (two boxes) * 4 + 1+ no of class. &nbsp;For VOC dataset they used if no of box = 2 and class = 20 having a depth of 2*4 + 1+ 20 = 30 resulting in the output tensor with shape 7x7x30.</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c2">Training Steps </span></p><p class="c4"><span class="c1">1. Preparing GT tensor : It is a good practice to prepare the mini-batch generator functions for training to output the same data format of the YOLO v1 model output. It should be of size (7x7xN) N = &nbsp;4 + 1 + no of classes. Now the loss can be calculated quite easily by comparing with the model output and train data since they have the same shape.</span></p><p class="c4"><span class="c1">2. Forward pass : Feed the RGB image to the model and extract the predicted tensor with shape 7x7xN</span></p><p class="c4"><span class="c1">3. xy_loss : slice the first 2 channels of the ground truth and prediction tensors both having shape 7x7x2 and calculate the squared difference.</span></p><p class="c4"><span class="c1">In numpy syntax it would be like this -<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt; xy_gt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = gt_tensor[ : , : , :2 ] </span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&gt;&gt; xy_pred &nbsp; &nbsp; &nbsp; &nbsp; = predicted_tensor[: , : , :2]</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&gt;&gt; xy_loss &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= numpy.mean (numpy.square(xy_gt - xy_pred))</span></p><p class="c4"><span class="c1">4. wh_loss : slice out the 3rd and 4th (tensor[:, :, 2:4]) channel and take their square root and calculate squared difference for w,h error.</span></p><p class="c4"><span class="c1">5. conf_loss :</span></p><p class="c4"><span class="c5 c13">&nbsp; &nbsp; &nbsp; - slice the 5th channel (tensor[:, :, 5]) and apply an object mask [1</span><span class="c5 c13 c19">obj</span><span class="c1">&nbsp;] on every cell. It means Multiply the locations with an object in GT with 1 else 0. Finally calculate mse among the masked </span></p><p class="c4"><span class="c1">tensores. </span></p><p class="c4"><span class="c5 c13">&nbsp; &nbsp; &nbsp;- calculate the loss again this time applying no object mask [1</span><span class="c5 c13 c19">nobj</span><span class="c5 c13">] on every cell. Add this loss with a smaller weight [&#x1d6cc;</span><span class="c0 c13">noobj &nbsp;</span><span class="c1">] because there will be lot of box with no object compared to object boxes in the GT.</span></p><p class="c4"><span class="c1">6.Class confidence loss : </span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; - Slice rest of the channels (tensor[:, :, 5: ]) , convert the raw values to conditional probabilities P(class | object) by multiplying with object confidence at the same location. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; - Then calculate the classification loss in the same way as confidence loss. Note currently softmax and cross entropy loss is used at this place in the SOTA methods.</span></p><p class="c4"><span class="c1">7. Finally, backpropagation is done with the calculated loss.</span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 439.50px; height: 296.24px;"><img alt="" src="files/yolo/image3.png" style="width: 439.50px; height: 296.24px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c2">Inference Steps :</span></p><p class="c4"><span class="c1">For drawing the bbox in the original image we need to project the predicted x,y,w,h to the respective locations of the actual image.</span></p><p class="c4"><span class="c1">&nbsp;- If the Image size = (416x416) and model output size = (7x7), the ratio of image and fmap is, &nbsp;grid-scale =416/7 = 13</span></p><p class="c4"><span class="c1">&nbsp;- Each of the 7x7 grids can be projected back to its parent location in the image by multiplying by grid-scale = 13.</span></p><p class="c4"><span class="c1">&nbsp;- Let&#39;s consider the following values for x,y,w,h = [0.3,0.2,4,5], in the above example at grid location [grid_x,grid_y] = [1,2].</span></p><p class="c4"><span class="c1">X = grid-scale * (grid_x + x) = 13 * (1 + 0.3) = &nbsp;16.9 ~ 17</span></p><p class="c4"><span class="c1">Y = grid-scale * (grid_y + y) = 13 * (2 + 0.2) = &nbsp;28.6 ~ 29</span></p><p class="c4"><span class="c1">W = grid-scale * w &nbsp;= 4 &nbsp;* 13 = 52</span></p><p class="c4"><span class="c1">H &nbsp;= grid-scale * h &nbsp; = 5 &nbsp;* 13 &nbsp;= 65</span></p><p class="c4"><span class="c1">The reverse would be like below,</span></p><p class="c4"><span class="c1">x = X / grid-scale - grid_x </span></p><p class="c4"><span class="c1">y = Y / grid-scale - grid_y </span></p><p class="c4"><span class="c1">w = W / grid-scale</span></p><p class="c4"><span class="c1">h = H /grid-scale</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c28 c37">SSD &nbsp;(</span><span class="c12">Single shot multi box detector.</span><span class="c27">)</span></p><hr><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">Unlike Faster RCNN both YOLO v1 and SSD eliminate the necessity of putting the RoI Feature maps one by one through the dense classifier layers. They are both single pass / single shot detectors. One image passes through the end to end network and predicts the bboxes along with class labels in one pass. </span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">SSD is better than YOLO v1 in the following ways :</span></p><p class="c4"><span class="c12">1. Multi scale feature maps : </span><span class="c5 c13">The feature maps with higher resolution would be able to predict the small objects better while smaller ones should take care of the large objects. It uses the different resolution feature maps from different stages of the model for final prediction. It helps the model to predict objects of different sizes more easily. &nbsp;The feature maps would have varying depths while for prediction we need fixed depth consisting of i.e x,y,w,h ,conf etc. They pass the arbitrary depth feature maps from different stages through a 3x3 </span><span class="c5 c13">conv</span><span class="c5 c13">. (convolutional) layer with depth k*(classes+4). From the outputs of the </span><span class="c5 c13">conv</span><span class="c1">. layer they calculate the boxes like YOLO V1. For mxn featuremap with k aspect ratio boxes it can predict k boxes at each of the m*n location resulting boxes = k*m*n. </span></p><p class="c4"><span class="c1">SSD predicts a total of 8732 boxes of different scaled feature maps.</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c7 c28">2. Default boxes :</span></p><p class="c4"><span class="c5">For each of the feature map scales they used the default box. It is similar to the anchor box in RCNN, see the anchor box section in &nbsp;my </span><span class="c10 c5 c13"><a class="c11" href="https://www.google.com/url?q=https://irfanhasib0.github.io/blogs/%23/rcnn/&amp;sa=D&amp;source=editors&amp;ust=1667572886863894&amp;usg=AOvVaw1qMC23BFs_SLNexzvUP1E6">RCNN &nbsp;Family</a></span><span class="c5 c13">&nbsp;</span><span class="c5">&nbsp;blog for better understanding of this part. Unlike Faster RCNN they used 9 boxes for each feature map scale with aspect ratios &nbsp;A</span><span class="c0">r</span><span class="c5">&nbsp;= {1,2,3,1/2,1/3}. They scaled the anchor boxes at different feature map levels with a scale factor which ensures the feature map stage emphasizes on learning the intended scales. In Faster RCNN they used three scales 128x128,256x256,512x512 each with 3 aspect ratio 1:1,1:2,2:1. In SSD each of the feature maps from each stage of the network corresponds to one scale, resulting in a total 6 scales. Each of the scales have 4,6,6,6,4,4 no of aspect ratios. The 1st stage of feature map (38x38) which can look at the small objects at higher resolution so they have not assigned the top 2 largest aspect ratios for it i.e A</span><span class="c0">r</span><span class="c7 c5">&nbsp;= {1,2,3,1/2,1/3}. For similar reasons the smallest 2 scales don&rsquo;t care about the large aspect ratio. For example scale 38x38 should learn small objects so they scaled it with small scale factor = 0.2. Scale, s = 0.2 and s = 0.9 all the intermediate feature maps are equally mapped. The small scale (0.2) for the 38x38 pushes it to find small boxes while the 1x1 map with scale 0.9 will try to find very big boxes at the center of the image.</span></p><p class="c4"><span class="c7 c5">Width and height is calculated from scale and aspect ratio as follows - width, &nbsp;w = s * sqrt(A) ; height, h = s/sqrt(A)</span></p><p class="c3"><span class="c7 c5"></span></p><ul class="c26 lst-kix_4gvvutwnlpi-0 start"><li class="c4 c8 li-bullet-0"><span class="c7 c5">l = 1 , 2, &nbsp;&hellip;., L</span></li><li class="c4 c8 li-bullet-0"><span class="c5">s = s</span><span class="c0">min</span><span class="c5">&nbsp;+[ (s</span><span class="c0">max</span><span class="c5">&nbsp;- s</span><span class="c0">min</span><span class="c7 c5">) * (l - 1) ] / (L - 1) = 0.20 , 0.34, 0.48, 0.62, 0.78, 0.90</span></li><li class="c4 c8 li-bullet-0"><span class="c5">A</span><span class="c0">r</span><span class="c7 c5">&nbsp;= {1,2,3,1/2,1/3}</span></li><li class="c4 c8 li-bullet-0"><span class="c7 c5">w = s * sqrt(A)</span></li><li class="c4 c8 li-bullet-0"><span class="c7 c5">h &nbsp;= s / sqrt(A)</span></li></ul><p class="c3"><span class="c22 c5"></span></p><p class="c3"><span class="c22 c5"></span></p><a id="t.9b72b9dae349839fa6519f8943a17651a0d7bd8d"></a><a id="t.1"></a><table class="c40"><tr class="c21"><td class="c24" colspan="1" rowspan="1"><p class="c6 c42"><span class="c22 c5"></span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c6"><span class="c5 c23">A =3 </span><span class="c25 c5 c23">(N/A)</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">A= 2</span></p></td><td class="c31" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">A=1</span></p></td><td class="c24" colspan="1" rowspan="1"><p class="c6"><span class="c5 c23">A= 1 ; s = sqrt(s</span><span class="c0 c23">l</span><span class="c5 c23">*s</span><span class="c0 c23">l+1</span><span class="c22 c5">))</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">A= 1/2</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c6"><span class="c5 c23">A= 1/3 </span><span class="c25 c5 c23">(N/A)</span></p></td></tr><tr class="c21"><td class="c24" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">Fmap size = 38x38</span></p><p class="c6"><span class="c22 c5">s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0.20</span></p><p class="c6"><span class="c22 c5">s&rsquo; = sqrt(0.2*0.38) = 0.28</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c6"><span class="c25 c5 c23">w = 0.2 * sqrt(3) &nbsp;= &nbsp;0.34</span></p><p class="c6"><span class="c25 c5 c23">h &nbsp;= 0.2 / sqrt(3) &nbsp; = 0.11</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">w = 0.2 * sqrt(2) &nbsp;= 0.28</span></p><p class="c6"><span class="c22 c5">h &nbsp;= &nbsp;0.2 / sqrt(2) = 0.14</span></p></td><td class="c31" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">w = 0.2 * sqrt(1) = 0.2</span></p><p class="c6"><span class="c22 c5">h &nbsp;= 0.2 * sqrt(1) = 0.2</span></p></td><td class="c24" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">w = 0.28 * sqrt(1/2) = 0.14</span></p><p class="c6"><span class="c5 c22">h &nbsp;= 0.28 / sqrt(1/2) &nbsp;= 0.28</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">w = 0.2 * sqrt(1/2) = 0.14</span></p><p class="c6"><span class="c22 c5">h &nbsp;= 0.2 / sqrt(1/2) &nbsp;= 0.28</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c6"><span class="c25 c5 c23">w = 0.2 * sqrt(1/3) = 0.11</span></p><p class="c6"><span class="c25 c5 c23">h &nbsp;= 0.2 / sqrt(1/3) = 0.34</span></p></td></tr><tr class="c21"><td class="c24" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">&hellip;</span></p><p class="c6"><span class="c22 c5">&hellip;</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">&hellip;</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">&hellip;</span></p></td><td class="c31" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">&hellip;</span></p></td><td class="c24" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">&hellip;</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">&hellip;</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">&hellip;</span></p><p class="c6"><span class="c22 c5">&hellip;</span></p></td></tr><tr class="c21"><td class="c24" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">Fmap size = 1x1</span></p><p class="c6"><span class="c22 c5">s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0.90</span></p><p class="c6"><span class="c22 c5">s&rsquo; = sqrt(0.9*1) = 0.94</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c6"><span class="c25 c5 c23">w = 0.90 * sqrt(3) &nbsp;= &nbsp;1.56</span></p><p class="c6"><span class="c25 c5 c23">h &nbsp;= 0.90 / sqrt(3) &nbsp; = 0.52</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">w= 0.90 * sqrt(2) &nbsp;= 1.27</span></p><p class="c6"><span class="c22 c5">h = &nbsp;0.90 / sqrt(2) = 0.63</span></p></td><td class="c31" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">w = 0.90 * sqrt(1) = 0.9</span></p><p class="c6"><span class="c22 c5">h &nbsp;= 0.90 * sqrt(1) = 0.9</span></p></td><td class="c24" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">w = 0.94 * sqrt(1/2) = 0.94</span></p><p class="c6"><span class="c22 c5">h &nbsp;= 0.94 / sqrt(1/2) &nbsp;= 0.94</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c6"><span class="c22 c5">w = 0.2 * sqrt(1/2) = 0.63</span></p><p class="c6"><span class="c22 c5">h &nbsp;= 0.2 / sqrt(1/2) &nbsp;= 1.27</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c6"><span class="c25 c5 c23">w = 0.2 * sqrt(1/3) = 0.52</span></p><p class="c6"><span class="c5 c23 c25">h &nbsp;= 0.2 / sqrt(1/3) = 1.56</span></p></td></tr></table><p class="c4"><span class="c5">&nbsp;</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 286.50px; height: 253.90px;"><img alt="" src="files/yolo/image1.png" style="width: 286.50px; height: 253.90px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 995.14px; height: 528.81px;"><img alt="" src="files/yolo/image6.png" style="width: 995.14px; height: 528.81px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c9">&nbsp;Image taken from SSD paper by Leu at el.</span></p><p class="c3"><span class="c9"></span></p><p class="c4"><span class="c7 c28">Loss Function :</span></p><p class="c4"><span class="c7 c5">&nbsp;The loss function is almost the same as Faster RCNN.</span></p><p class="c4"><span class="c5">- Loss = &nbsp; L</span><span class="c0">cls</span><span class="c5">&nbsp;+ alpha * L</span><span class="c18 c0">loc</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= &nbsp; L</span><span class="c0">loc</span><span class="c5">&nbsp;is the same as Faster RCNN + L</span><span class="c0">cls</span><span class="c7 c5">&nbsp;is softmax over the classes.</span></p><p class="c3"><span class="c12 c35"></span></p><p class="c4"><span class="c12">3. Less model parameters :</span><span class="c5 c13">&nbsp;YOLO V1 It sends the flattened outputs of the </span><span class="c5 c13">conv</span><span class="c5 c13">. Feature maps to the fully connected layers and resized them again into </span><span class="c5 c13">conv</span><span class="c5 c13">. 7x7x30 (for VOC) feature maps. Dense layers require a lot more parameters (for taking the flattened input from the previous </span><span class="c5 c13">conv</span><span class="c5 c13">. layer) then just another </span><span class="c5 c13">conv</span><span class="c5 c13">. layer. Because it </span><span class="c5 c13">need</span><span class="c1">&nbsp;to be flattened &nbsp;Conv. layer may have parameters</span></p><p class="c4"><span class="c1">If the conv layer was directly bypassed to the next conv layter skipping the dense layers using a 3x3 conv kernel &nbsp;the number of weights would be [3x3x512x1024] + [3x3x1024x30] &nbsp;~ 4.9e6</span></p><p class="c4"><span class="c1">- If we do it with a single dense layer. The dense layer can only take the flattened results of [7x7x512x1024] &nbsp;sized tensor resulting ~ 25e6 input nodes. It should output [7x7x30] ~ 1.4e3 weights so that it can be easily resized to 7x7x30 again. The weight for this dense layer would be [7x7x512x1024] x [7x7x30] ~ 37e9</span></p><p class="c4"><span class="c1">It should require at least &nbsp;~1000 times more parameters for this transition part.</span></p><p class="c3"><span class="c9"></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c3"><span class="c9"></span></p><p class="c4"><span class="c27">YOLO Version 2</span></p><hr><p class="c3"><span class="c7 c5"></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c7 c5">1. YOLO v2 also anchor boxes at each of the grid locations in the featuremap like Faster RCNN and SSD. They make the model learn the grid offset in x,y direction, log scale offset is learnt for w and h. Unlike the previous approaches they don&rsquo;t hard code (Faster RCNN) or derive the anchor box from some empirical formula (SSD). They perform k means clustering over all the w and h of the bboxes in train data.</span></p><p class="c4"><span class="c7 c5">2. They used k-means clustering over all the images of the dataset for finding the most optimal k number of anchor boxes for different values of k. They found 5 anchor boxes to work best in YOLO-v2. YOLO-v3 eventually adopted 9 anchor boxes from 3 scales.</span></p><p class="c4"><span class="c7 c5">3. They found batch normalization very effective.</span></p><p class="c4"><span class="c7 c5">4. They used higher resolution images this time (416x416). They also trained the model with different resolution images &nbsp;during the training for making it robust to image size.</span></p><p class="c4"><span class="c7 c5">5. They adopted an identity mapping approach similar to ResNet. They copied the output of an older layer and added it to the activations of deeper layers.</span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 358.50px; height: 266.97px;"><img alt="" src="files/yolo/image4.png" style="width: 358.50px; height: 266.97px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c32 c28">&nbsp; &nbsp; &nbsp; &nbsp;Image taken from YOLO v2 paper by Redmon at el. &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c3"><span class="c7 c5"></span></p><ul class="c26 lst-kix_10bg29dgyeg1-0 start"><li class="c4 c8 li-bullet-0"><span class="c5">b</span><span class="c0">x</span><span class="c5">&nbsp;= sig(t</span><span class="c0">x</span><span class="c5">) + c</span><span class="c0 c18">x</span></li><li class="c4 c8 li-bullet-0"><span class="c5">b</span><span class="c0">y</span><span class="c5">&nbsp;= sig(t</span><span class="c0">y</span><span class="c5">) +c</span><span class="c18 c0">y</span></li><li class="c4 c8 li-bullet-0"><span class="c5">b</span><span class="c0">w</span><span class="c5">&nbsp;= </span><span class="c5">p</span><span class="c0">w</span><span class="c5">e</span><span class="c5 c19">tw</span></li><li class="c4 c8 li-bullet-0"><span class="c5">b</span><span class="c0">h</span><span class="c5">&nbsp;= p</span><span class="c5 c19">h</span><span class="c5">e</span><span class="c18 c5 c19">th</span></li></ul><p class="c3"><span class="c18 c5 c19"></span></p><p class="c4"><span class="c7 c5">&nbsp;For x,y the model is learning the difference between b and c which is the grid offset. (To be precise the model is learning the inverse sigmoid of the grid offset.) For w and h, the model is learning the difference of logarithmic values of each of them.</span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c0">&nbsp; </span><span class="c5">The outputs of the model are &nbsp;t</span><span class="c0">x ,</span><span class="c5">t</span><span class="c0">y, </span><span class="c5">t</span><span class="c0">w, </span><span class="c5">t</span><span class="c0">h</span><span class="c7 c5">&nbsp;which are the offsets being learnt finally. &nbsp;The below equations may give further intuition about them.</span></p><ul class="c26 lst-kix_y89d79xx04k4-0 start"><li class="c4 c8 li-bullet-0"><span class="c5">t</span><span class="c0">x</span><span class="c5">&nbsp;= inv_sig( b</span><span class="c0">x</span><span class="c5">&nbsp;- c</span><span class="c0">x</span><span class="c7 c5">)</span></li><li class="c4 c8 li-bullet-0"><span class="c5">t</span><span class="c0">y</span><span class="c5">&nbsp;= inv_sig((b</span><span class="c0">y</span><span class="c5">&nbsp;- c</span><span class="c0">y</span><span class="c7 c5">)</span></li><li class="c4 c8 li-bullet-0"><span class="c5">t</span><span class="c0">w</span><span class="c5">&nbsp;= log(b</span><span class="c0">w</span><span class="c5">/p</span><span class="c0">w</span><span class="c5">) = log(b</span><span class="c0">w</span><span class="c5">) - log(p</span><span class="c0">w</span><span class="c7 c5">)</span></li><li class="c4 c8 li-bullet-0"><span class="c5">t</span><span class="c0">h</span><span class="c5">&nbsp;= &nbsp;log(b</span><span class="c0">h</span><span class="c5">/p</span><span class="c0">h</span><span class="c5">) = log(b</span><span class="c0">w</span><span class="c5">) - log(p</span><span class="c0">w</span><span class="c7 c5">)</span></li></ul><p class="c3 c29"><span class="c7 c5"></span></p><p class="c4"><span class="c7 c5">where,</span></p><ul class="c26 lst-kix_8s7n3kf664eg-0 start"><li class="c4 c8 li-bullet-0"><span class="c7 c5">sig(x) = Sigmoid(x) &nbsp; = 1/ (1+e-x) </span></li><li class="c4 c8 li-bullet-0"><span class="c7 c5">inv_sig(x) = Inverse Sigmoid(x) = &nbsp;log(x/(1 -x))</span></li></ul><p class="c3 c29"><span class="c7 c5"></span></p><p class="c4"><span class="c5">Sigmoid bounds a (-inf , </span><span class="c5">inf</span><span class="c7 c5">) function output within (0-1). So the inverse sigmoid should do the opposite and make the model capable of outputting any arbitrary value from -inf to inf. The model can output any arbitrary value as offset (before the sigmoid is applied) but sigmoid will transform it to corresponding 0-1 value for fitting into the grid while adding some nonlinearity to the process. Addition of non-linearity is very important, because it enables the model to learn complex underlying functions beyond the linear domain.</span></p><p class="c3"><span class="c7 c28"></span></p><p class="c4"><span class="c28">Selective backpropagation : </span><span class="c7 c5">During training if an bbox has low overlap with the ground truth then back propagation can be skipped for that particular loss.</span></p><p class="c4"><span class="c7 c5">There are some post prediction techniques that are commonly practiced for better accuracy.</span></p><p class="c4"><span class="c28">Removing low confidence boxes boxes :</span><span class="c5">&nbsp;After prediction is done bboxes lower than a minimum (i.e 0.3) confidence, P(Class|</span><span class="c5">Object</span><span class="c7 c5">) are filtered out for better accuracy.</span></p><p class="c4"><span class="c28">Non Maximum Suppression :</span><span class="c7 c5">&nbsp; If some of the prediction boxes try to predict the same object with different confidence they should have a good overlap. For prediction boxes with IoU more than a threshold (i.e 0.5) only the one with highest confidence is kept.</span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c28">Word Tree :</span><span class="c7 c5">&nbsp;YOLO v2 introduced a way for incorporating large classification data sets (without bbox labels i.e ImageNet 1000) to be introduced within the framework. During training if an image samples from a classification dataset then only classification loss is calculated else it will calculate all the losses. For unifying the 1000 classes of imageNet to COCO 80 classes the each of the fine grained categories (i.e persian cat) is mapped back to its parent category present in COCO dataset (i.e cat). They have accomplished it by using the concept from Word Net from the Natural language processing domain. </span></p><p class="c3"><span class="c7 c5"></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 730.85px; height: 428.17px;"><img alt="" src="files/yolo/image5.png" style="width: 730.85px; height: 428.17px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c32 c28">Figure : The core idea of YOLO is to find a vector like above at every pixel location in the feature map (not image).</span></p><p class="c3"><span class="c7 c5"></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c27">Yolo Version 3</span></p><hr><p class="c3"><span class="c27"></span></p><p class="c4"><span class="c7 c5">- The main improvement in YOLO-v3 is extraction of data from three different scales from the feature map. They were inspired by the FPN[6] networks for tracking this direction. The success of SSD can also be a &nbsp;good reason. They have taken the feature maps from the last layer for small box prediction. Then upsmple it by doubling the size and concatenating it with the feature maps from 2 layers back to predict medium sized boxes. They have repeated the same and predicted large boxes from feature maps from 2 more laye back.</span></p><p class="c4"><span class="c7 c5">- They have used 9 anchor boxes (instead of 5) , sorted them by size and divided them into three scales: large , medium and small. Each of the 3 anchor boxes are applied on the corresponding feature maps extracted from the network.</span></p><p class="c4"><span class="c7 c5">- For confidence loss they used logistic losses instead of mean squared error. Although, it is a very common practice nowadays.</span></p><p class="c4"><span class="c7 c5">- Softmax needs the class labels to be mutually exclusive. Each grid cell can occupy multiple objects from different classes at different scales. Like one person standing behind a car having their center at the same location in the image. They replaced the idea of using the softmax for each grid cell location </span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c7 c5">I will show an example dimension through the figure for understanding it better considering the mobile net v2</span></p><p class="c4"><span class="c7 c5">as a backbone with input image shape 224x224 for other networks or input size it can be different.</span></p><p class="c4"><span class="c7 c5">I will demonstrate with 80 classes considering the coco dataset. </span></p><p class="c4"><span class="c7 c5">The authors used image size ~ 416x416 with darknet 53</span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 770.92px; height: 552.59px;"><img alt="" src="files/yolo/image2.png" style="width: 770.92px; height: 552.59px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c28 c32">Figure : YOLO V3</span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c7 c28">1x1 conv + Reshape</span></p><p class="c4"><span class="c7 c5">1x1 convolution layer can change the depth of a feature map array keeping the height and width as it is. Here it is used to change the depth of the output featuremap &nbsp;to appropriate dimension so that it can be reshaped to our desired dimension. For this purpose the 1x1 conv should change any arbitrary depth to a length equals to anc box* (4+1+no of class). Height and width remains the same after applying 1x1 convolution. Then reshape is applied to make and extra dimension of size=3 (anc. box). Using a separate dimension for the anchor box is convenient for implementation. Numerical operations in many popular libraries can easily be applied on a dimension of an array. </span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c7 c28">Decode outputs to bboxes :</span></p><p class="c4"><span class="c7 c5">1. Decode the bboxes and class from the output 4d array using respective anchor boxes for that feature map scale. Note that the same anchor boxes</span></p><p class="c4"><span class="c7 c5">are also required for loss calculation.</span></p><p class="c4"><span class="c7 c5">2. Low conf. bbox removal</span></p><p class="c4"><span class="c7 c5">3. Non maximum suppression</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 816.50px; height: 357.62px;"><img alt="" src="files/yolo/image8.png" style="width: 816.50px; height: 357.62px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c32 c28">Figure : &nbsp;(Left) Non Maximum Suppression (Middle) Total 9 anchor boxes at every fmap locations (Right) IoU and multi aspect ratio objects at one location. </span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c7 c28">Code :</span></p><p class="c4"><span class="c5">Yolo V4 : </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://github.com/irfanhasib0/Deep-Learning-For-Computer-Vision/tree/main/yolo-v4&amp;sa=D&amp;source=editors&amp;ust=1667572886878031&amp;usg=AOvVaw0re2-BBXXMkh2b1bWjFWPE">https://github.com/irfanhasib0/Deep-Learning-For-Computer-Vision/tree/main/yolo-v4</a></span></p><p class="c3"><span class="c7 c28"></span></p><p class="c4"><span class="c35 c28 c39">References </span></p><hr><p class="c3"><span class="c7 c28"></span></p><p class="c4"><span class="c7 c5">Papers :</span></p><p class="c4"><span class="c5">1. Faster R-CNN: </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://arxiv.org/abs/1506.01497&amp;sa=D&amp;source=editors&amp;ust=1667572886878547&amp;usg=AOvVaw26UgQarH_ej1iL_KBG8ctU">https://arxiv.org/abs/1506.01497</a></span></p><p class="c4"><span class="c5">2. You Only Look Once: Unified, Real-Time Object Detection : </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://arxiv.org/pdf/1506.02640.pdf&amp;sa=D&amp;source=editors&amp;ust=1667572886878762&amp;usg=AOvVaw2SEFTlAnnT6gNp1dR0mcpY">https://arxiv.org/pdf/1506.02640.pdf</a></span></p><p class="c4"><span class="c5">3. SSD: Single Shot MultiBox Detector : </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://arxiv.org/abs/1512.02325&amp;sa=D&amp;source=editors&amp;ust=1667572886878955&amp;usg=AOvVaw08RUHSEV9B_2VmSIpBU57T">https://arxiv.org/abs/1512.02325</a></span></p><p class="c4"><span class="c5">4. YOLO9000: Better, Faster, Stronger : </span><span class="c5 c10"><a class="c11" href="https://www.google.com/url?q=https://arxiv.org/abs/1612.08242&amp;sa=D&amp;source=editors&amp;ust=1667572886879176&amp;usg=AOvVaw2_mmfQWNzn0m45SiSEM9_g">https://arxiv.org/abs/1612.08242</a></span></p><p class="c4"><span class="c5">5. YOLOv3: An Incremental Improvement : </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://arxiv.org/abs/1804.02767?e05802c1_page%3D1&amp;sa=D&amp;source=editors&amp;ust=1667572886879377&amp;usg=AOvVaw1tNnmdRTuFcQz5vNoC6-_q">https://arxiv.org/abs/1804.02767?e05802c1_page=1</a></span></p><p class="c4"><span class="c5">6. Feature Pyramid Networks for Object Detection : </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://arxiv.org/pdf/1612.03144.pdf&amp;sa=D&amp;source=editors&amp;ust=1667572886879592&amp;usg=AOvVaw2-8gmS4DRasqbTgAXofb_N">https://arxiv.org/pdf/1612.03144.pdf</a></span></p><p class="c4"><span class="c5">7. Mask R-CNN: </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://arxiv.org/abs/1703.06870&amp;sa=D&amp;source=editors&amp;ust=1667572886879784&amp;usg=AOvVaw33-UWdYOWM_IOueY8roPqB">https://arxiv.org/abs/1703.06870</a></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c4"><span class="c7 c5">Blogs :</span></p><p class="c4"><span class="c5">1. </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://lilianweng.github.io/posts/2018-12-27-object-recognition-part-4/&amp;sa=D&amp;source=editors&amp;ust=1667572886880212&amp;usg=AOvVaw0UYm0j4ugeLCQUycD2A55e">https://lilianweng.github.io/posts/2018-12-27-object-recognition-part-4/</a></span></p><p class="c4"><span class="c5">2. </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://jonathan-hui.medium.com/real-time-object-detection-with-yolo-yolov2-28b1b93e2088&amp;sa=D&amp;source=editors&amp;ust=1667572886880453&amp;usg=AOvVaw27v19PRKLSQXIhSdpssUNt">https://jonathan-hui.medium.com/real-time-object-detection-with-yolo-yolov2-28b1b93e2088</a></span></p><p class="c4"><span class="c5">3. </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://medium.com/@venkatakrishna.jonnalagadda/object-detection-yolo-v1-v2-v3-c3d5eca2312a&amp;sa=D&amp;source=editors&amp;ust=1667572886880759&amp;usg=AOvVaw2432Q_NJyzFUmO7543VnNw">https://medium.com/@venkatakrishna.jonnalagadda/object-detection-yolo-v1-v2-v3-c3d5eca2312a</a></span></p><p class="c4"><span class="c5">4. </span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://jonathan-hui.medium.com/ssd-object-detection-single-shot-multibox-detector-for-real-time-processing-9bd8deac0e06&amp;sa=D&amp;source=editors&amp;ust=1667572886881118&amp;usg=AOvVaw19hzJd5r2W5iL2-DLlEbfb">https://jonathan-hui.medium.com/ssd-object-detection-single-shot-multibox-detector-for-real-time-processing-9bd8deac0e06</a></span></p><p class="c4"><span class="c5">5.</span><span class="c10 c5"><a class="c11" href="https://www.google.com/url?q=https://medium.com/inveterate-learner/real-time-object-detection-part-1-understanding-ssd-65797a5e675b%23:~:text%3DSSD%2520contains%25208732%2520default%2520boxes,to%2520obtain%2520the%2520final%2520prediction.&amp;sa=D&amp;source=editors&amp;ust=1667572886881402&amp;usg=AOvVaw29gcEgg4VJQ8OO2WqZ7Cy2">https://medium.com/inveterate-learner/real-time-object-detection-part-1-understanding-ssd-65797a5e675b#:~:text=SSD%20contains%208732%20default%20boxes,to%20obtain%20the%20final%20prediction.</a></span></p><p class="c3"><span class="c7 c5"></span></p><p class="c3"><span class="c7 c5"></span></p></body></html>